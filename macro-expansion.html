<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Macro expansion - Guide to Rustc Development</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="A guide to developing rustc">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = default_theme; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li class="affix"><a href="about-this-guide.html">About this guide</a></li><li class="spacer"></li><li><a href="part-1-intro.html"><strong aria-hidden="true">1.</strong> Part 1: Building, debugging, and contributing to Rustc</a></li><li><a href="compiler-team.html"><strong aria-hidden="true">2.</strong> About the compiler team</a></li><li><a href="how-to-build-and-run.html"><strong aria-hidden="true">3.</strong> How to build the compiler and run what you built</a></li><li><ol class="section"><li><a href="build-install-distribution-artifacts.html"><strong aria-hidden="true">3.1.</strong> Build and Install distribution artifacts</a></li><li><a href="compiler-documenting.html"><strong aria-hidden="true">3.2.</strong> Documenting Compiler</a></li></ol></li><li><a href="tests/intro.html"><strong aria-hidden="true">4.</strong> The compiler testing framework</a></li><li><ol class="section"><li><a href="tests/running.html"><strong aria-hidden="true">4.1.</strong> Running tests</a></li><li><a href="tests/adding.html"><strong aria-hidden="true">4.2.</strong> Adding new tests</a></li><li><a href="compiletest.html"><strong aria-hidden="true">4.3.</strong> Using compiletest + commands to control test execution</a></li></ol></li><li><a href="walkthrough.html"><strong aria-hidden="true">5.</strong> Walkthrough: a typical contribution</a></li><li><a href="implementing_new_features.html"><strong aria-hidden="true">6.</strong> Implementing new features</a></li><li><a href="stabilization_guide.html"><strong aria-hidden="true">7.</strong> Stabilizing Features</a></li><li><a href="compiler-debugging.html"><strong aria-hidden="true">8.</strong> Debugging the Compiler</a></li><li><a href="profiling.html"><strong aria-hidden="true">9.</strong> Profiling the compiler</a></li><li><ol class="section"><li><a href="profiling/with_perf.html"><strong aria-hidden="true">9.1.</strong> with the linux perf tool</a></li></ol></li><li><a href="conventions.html"><strong aria-hidden="true">10.</strong> Coding conventions</a></li><li><a href="crates-io.html"><strong aria-hidden="true">11.</strong> crates.io Dependencies</a></li><li class="spacer"></li><li><a href="part-2-intro.html"><strong aria-hidden="true">12.</strong> Part 2: How rustc works</a></li><li><a href="high-level-overview.html"><strong aria-hidden="true">13.</strong> High-level overview of the compiler source</a></li><li><a href="rustc-driver.html"><strong aria-hidden="true">14.</strong> The Rustc Driver and Interface</a></li><li><ol class="section"><li><a href="rustdoc.html"><strong aria-hidden="true">14.1.</strong> Rustdoc</a></li></ol></li><li><a href="query.html"><strong aria-hidden="true">15.</strong> Queries: demand-driven compilation</a></li><li><ol class="section"><li><a href="queries/query-evaluation-model-in-detail.html"><strong aria-hidden="true">15.1.</strong> The Query Evaluation Model in Detail</a></li><li><a href="queries/incremental-compilation.html"><strong aria-hidden="true">15.2.</strong> Incremental compilation</a></li><li><a href="queries/incremental-compilation-in-detail.html"><strong aria-hidden="true">15.3.</strong> Incremental compilation In Detail</a></li><li><a href="incrcomp-debugging.html"><strong aria-hidden="true">15.4.</strong> Debugging and Testing</a></li></ol></li><li><a href="the-parser.html"><strong aria-hidden="true">16.</strong> The parser</a></li><li><a href="test-implementation.html"><strong aria-hidden="true">17.</strong> #[test] Implementation</a></li><li><a href="macro-expansion.html" class="active"><strong aria-hidden="true">18.</strong> Macro expansion</a></li><li><a href="name-resolution.html"><strong aria-hidden="true">19.</strong> Name resolution</a></li><li><a href="hir.html"><strong aria-hidden="true">20.</strong> The HIR (High-level IR)</a></li><li><ol class="section"><li><a href="lowering.html"><strong aria-hidden="true">20.1.</strong> Lowering AST to HIR</a></li><li><a href="hir-debugging.html"><strong aria-hidden="true">20.2.</strong> Debugging</a></li></ol></li><li><a href="ty.html"><strong aria-hidden="true">21.</strong> The ty module: representing types</a></li><li><a href="kinds.html"><strong aria-hidden="true">22.</strong> Kinds</a></li><li><a href="type-inference.html"><strong aria-hidden="true">23.</strong> Type inference</a></li><li><a href="traits/resolution.html"><strong aria-hidden="true">24.</strong> Trait solving (old-style)</a></li><li><ol class="section"><li><a href="traits/hrtb.html"><strong aria-hidden="true">24.1.</strong> Higher-ranked trait bounds</a></li><li><a href="traits/caching.html"><strong aria-hidden="true">24.2.</strong> Caching subtleties</a></li><li><a href="traits/specialization.html"><strong aria-hidden="true">24.3.</strong> Specialization</a></li></ol></li><li><a href="traits/index.html"><strong aria-hidden="true">25.</strong> Trait solving (new-style)</a></li><li><ol class="section"><li><a href="traits/lowering-to-logic.html"><strong aria-hidden="true">25.1.</strong> Lowering to logic</a></li><li><ol class="section"><li><a href="traits/goals-and-clauses.html"><strong aria-hidden="true">25.1.1.</strong> Goals and clauses</a></li><li><a href="traits/associated-types.html"><strong aria-hidden="true">25.1.2.</strong> Equality and associated types</a></li><li><a href="traits/implied-bounds.html"><strong aria-hidden="true">25.1.3.</strong> Implied bounds</a></li><li><a href="traits/regions.html"><strong aria-hidden="true">25.1.4.</strong> Region constraints</a></li><li><a href="traits/lowering-module.html"><strong aria-hidden="true">25.1.5.</strong> The lowering module in rustc</a></li><li><a href="traits/lowering-rules.html"><strong aria-hidden="true">25.1.6.</strong> Lowering rules</a></li><li><a href="traits/wf.html"><strong aria-hidden="true">25.1.7.</strong> Well-formedness checking</a></li></ol></li><li><a href="traits/canonical-queries.html"><strong aria-hidden="true">25.2.</strong> Canonical queries</a></li><li><ol class="section"><li><a href="traits/canonicalization.html"><strong aria-hidden="true">25.2.1.</strong> Canonicalization</a></li></ol></li><li><a href="traits/slg.html"><strong aria-hidden="true">25.3.</strong> The SLG solver</a></li><li><a href="traits/chalk-overview.html"><strong aria-hidden="true">25.4.</strong> An Overview of Chalk</a></li><li><a href="traits/bibliography.html"><strong aria-hidden="true">25.5.</strong> Bibliography</a></li></ol></li><li><a href="type-checking.html"><strong aria-hidden="true">26.</strong> Type checking</a></li><li><ol class="section"><li><a href="method-lookup.html"><strong aria-hidden="true">26.1.</strong> Method Lookup</a></li><li><a href="variance.html"><strong aria-hidden="true">26.2.</strong> Variance</a></li><li><a href="existential-types.html"><strong aria-hidden="true">26.3.</strong> Existential Types</a></li></ol></li><li><a href="mir/index.html"><strong aria-hidden="true">27.</strong> The MIR (Mid-level IR)</a></li><li><ol class="section"><li><a href="mir/construction.html"><strong aria-hidden="true">27.1.</strong> MIR construction</a></li><li><a href="mir/visitor.html"><strong aria-hidden="true">27.2.</strong> MIR visitor and traversal</a></li><li><a href="mir/passes.html"><strong aria-hidden="true">27.3.</strong> MIR passes: getting the MIR for a function</a></li><li><a href="mir/optimizations.html"><strong aria-hidden="true">27.4.</strong> MIR optimizations</a></li><li><a href="mir/debugging.html"><strong aria-hidden="true">27.5.</strong> Debugging</a></li></ol></li><li><a href="borrow_check.html"><strong aria-hidden="true">28.</strong> The borrow checker</a></li><li><ol class="section"><li><a href="borrow_check/moves_and_initialization.html"><strong aria-hidden="true">28.1.</strong> Tracking moves and initialization</a></li><li><ol class="section"><li><a href="borrow_check/moves_and_initialization/move_paths.html"><strong aria-hidden="true">28.1.1.</strong> Move paths</a></li></ol></li><li><a href="borrow_check/type_check.html"><strong aria-hidden="true">28.2.</strong> MIR type checker</a></li><li><a href="borrow_check/region_inference.html"><strong aria-hidden="true">28.3.</strong> Region inference</a></li></ol></li><li><a href="const-eval.html"><strong aria-hidden="true">29.</strong> Constant evaluation</a></li><li><ol class="section"><li><a href="miri.html"><strong aria-hidden="true">29.1.</strong> miri const evaluator</a></li></ol></li><li><a href="param_env.html"><strong aria-hidden="true">30.</strong> Parameter Environments</a></li><li><a href="codegen.html"><strong aria-hidden="true">31.</strong> Code Generation</a></li><li><ol class="section"><li><a href="codegen/updating-llvm.html"><strong aria-hidden="true">31.1.</strong> Updating LLVM</a></li><li><a href="codegen/debugging.html"><strong aria-hidden="true">31.2.</strong> Debugging LLVM</a></li></ol></li><li><a href="diag.html"><strong aria-hidden="true">32.</strong> Emitting Diagnostics</a></li><li><ol class="section"><li><a href="diag/json-format.html"><strong aria-hidden="true">32.1.</strong> JSON diagnostic format</a></li><li class="spacer"></li></ol></li><li><a href="appendix/stupid-stats.html">Appendix A: Stupid Stats</a></li><li class="affix"><a href="appendix/background.html">Appendix B: Background material</a></li><li class="affix"><a href="appendix/glossary.html">Appendix C: Glossary</a></li><li class="affix"><a href="appendix/code-index.html">Appendix D: Code Index</a></li><li class="affix"><a href="important-links.html"></a></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Guide to Rustc Development</h1> 

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="#macro-expansion" id="macro-expansion"><h1>Macro expansion</h1></a>
<p>Macro expansion happens during parsing. <code>rustc</code> has two parsers, in fact: the
normal Rust parser, and the macro parser. During the parsing phase, the normal
Rust parser will set aside the contents of macros and their invocations. Later,
before name resolution, macros are expanded using these portions of the code.
The macro parser, in turn, may call the normal Rust parser when it needs to
bind a metavariable (e.g.  <code>$my_expr</code>) while parsing the contents of a macro
invocation. The code for macro expansion is in
<a href="https://github.com/rust-lang/rust/tree/master/src/libsyntax/ext/tt"><code>src/libsyntax/ext/tt/</code></a>. This chapter aims to explain how macro
expansion works.</p>
<a class="header" href="#example" id="example"><h3>Example</h3></a>
<p>It's helpful to have an example to refer to. For the remainder of this chapter,
whenever we refer to the &quot;example <em>definition</em>&quot;, we mean the following:</p>
<pre><code class="language-rust ignore">macro_rules! printer {
    (print $mvar:ident) =&gt; {
        println!(&quot;{}&quot;, $mvar);
    }
    (print twice $mvar:ident) =&gt; {
        println!(&quot;{}&quot;, $mvar);
        println!(&quot;{}&quot;, $mvar);
    }
}
</code></pre>
<p><code>$mvar</code> is called a <em>metavariable</em>. Unlike normal variables, rather than
binding to a value in a computation, a metavariable binds <em>at compile time</em> to
a tree of <em>tokens</em>.  A <em>token</em> is a single &quot;unit&quot; of the grammar, such as an
identifier (e.g. <code>foo</code>) or punctuation (e.g. <code>=&gt;</code>). There are also other
special tokens, such as <code>EOF</code>, which indicates that there are no more tokens.
Token trees resulting from paired parentheses-like characters (<code>(</code>...<code>)</code>,
<code>[</code>...<code>]</code>, and <code>{</code>...<code>}</code>) – they include the open and close and all the tokens
in between (we do require that parentheses-like characters be balanced). Having
macro expansion operate on token streams rather than the raw bytes of a source
file abstracts away a lot of complexity. The macro expander (and much of the
rest of the compiler) doesn't really care that much about the exact line and
column of some syntactic construct in the code; it cares about what constructs
are used in the code. Using tokens allows us to care about <em>what</em> without
worrying about <em>where</em>. For more information about tokens, see the
<a href="./the-parser.html">Parsing</a> chapter of this book.</p>
<p>Whenever we refer to the &quot;example <em>invocation</em>&quot;, we mean the following snippet:</p>
<pre><code class="language-rust ignore">printer!(print foo); // Assume `foo` is a variable defined somewhere else...
</code></pre>
<p>The process of expanding the macro invocation into the syntax tree
<code>println!(&quot;{}&quot;, foo)</code> and then expanding that into a call to <code>Display::fmt</code> is
called <em>macro expansion</em>, and it is the topic of this chapter.</p>
<a class="header" href="#the-macro-parser" id="the-macro-parser"><h3>The macro parser</h3></a>
<p>There are two parts to macro expansion: parsing the definition and parsing the
invocations. Interestingly, both are done by the macro parser.</p>
<p>Basically, the macro parser is like an NFA-based regex parser. It uses an
algorithm similar in spirit to the <a href="https://en.wikipedia.org/wiki/Earley_parser">Earley parsing
algorithm</a>. The macro parser is
defined in <a href="https://doc.rust-lang.org/nightly/nightly-rustc/syntax/ext/tt/macro_parser/"><code>src/libsyntax/ext/tt/macro_parser.rs</code></a>.</p>
<p>The interface of the macro parser is as follows (this is slightly simplified):</p>
<pre><code class="language-rust ignore">fn parse(
    sess: ParserSession,
    tts: TokenStream,
    ms: &amp;[TokenTree]
) -&gt; NamedParseResult
</code></pre>
<p>In this interface:</p>
<ul>
<li><code>sess</code> is a &quot;parsing session&quot;, which keeps track of some metadata. Most
notably, this is used to keep track of errors that are generated so they can
be reported to the user.</li>
<li><code>tts</code> is a stream of tokens. The macro parser's job is to consume the raw
stream of tokens and output a binding of metavariables to corresponding token
trees.</li>
<li><code>ms</code> a <em>matcher</em>. This is a sequence of token trees that we want to match
<code>tts</code> against.</li>
</ul>
<p>In the analogy of a regex parser, <code>tts</code> is the input and we are matching it
against the pattern <code>ms</code>. Using our examples, <code>tts</code> could be the stream of
tokens containing the inside of the example invocation <code>print foo</code>, while <code>ms</code>
might be the sequence of token (trees) <code>print $mvar:ident</code>.</p>
<p>The output of the parser is a <code>NamedParseResult</code>, which indicates which of
three cases has occurred:</p>
<ul>
<li>Success: <code>tts</code> matches the given matcher <code>ms</code>, and we have produced a binding
from metavariables to the corresponding token trees.</li>
<li>Failure: <code>tts</code> does not match <code>ms</code>. This results in an error message such as
&quot;No rule expected token <em>blah</em>&quot;.</li>
<li>Error: some fatal error has occurred <em>in the parser</em>. For example, this
happens if there are more than one pattern match, since that indicates
the macro is ambiguous.</li>
</ul>
<p>The full interface is defined <a href="https://doc.rust-lang.org/nightly/nightly-rustc/syntax/ext/tt/macro_parser/fn.parse.html">here</a>.</p>
<p>The macro parser does pretty much exactly the same as a normal regex parser with
one exception: in order to parse different types of metavariables, such as
<code>ident</code>, <code>block</code>, <code>expr</code>, etc., the macro parser must sometimes call back to the
normal Rust parser.</p>
<p>As mentioned above, both definitions and invocations of macros are parsed using
the macro parser. This is extremely non-intuitive and self-referential. The code
to parse macro <em>definitions</em> is in
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/syntax/ext/tt/macro_rules/"><code>src/libsyntax/ext/tt/macro_rules.rs</code></a>. It defines the pattern for
matching for a macro definition as <code>$( $lhs:tt =&gt; $rhs:tt );+</code>. In other words,
a <code>macro_rules</code> definition should have in its body at least one occurrence of a
token tree followed by <code>=&gt;</code> followed by another token tree. When the compiler
comes to a <code>macro_rules</code> definition, it uses this pattern to match the two token
trees per rule in the definition of the macro <em>using the macro parser itself</em>.
In our example definition, the metavariable <code>$lhs</code> would match the patterns of
both arms: <code>(print $mvar:ident)</code> and <code>(print twice $mvar:ident)</code>.  And <code>$rhs</code>
would match the bodies of both arms: <code>{ println!(&quot;{}&quot;, $mvar); }</code> and <code>{ println!(&quot;{}&quot;, $mvar); println!(&quot;{}&quot;, $mvar); }</code>. The parser would keep this
knowledge around for when it needs to expand a macro invocation.</p>
<p>When the compiler comes to a macro invocation, it parses that invocation using
the same NFA-based macro parser that is described above. However, the matcher
used is the first token tree (<code>$lhs</code>) extracted from the arms of the macro
<em>definition</em>. Using our example, we would try to match the token stream <code>print foo</code> from the invocation against the matchers <code>print $mvar:ident</code> and <code>print twice $mvar:ident</code> that we previously extracted from the definition.  The
algorithm is exactly the same, but when the macro parser comes to a place in the
current matcher where it needs to match a <em>non-terminal</em> (e.g. <code>$mvar:ident</code>),
it calls back to the normal Rust parser to get the contents of that
non-terminal. In this case, the Rust parser would look for an <code>ident</code> token,
which it finds (<code>foo</code>) and returns to the macro parser. Then, the macro parser
proceeds in parsing as normal. Also, note that exactly one of the matchers from
the various arms should match the invocation; if there is more than one match,
the parse is ambiguous, while if there are no matches at all, there is a syntax
error.</p>
<p>For more information about the macro parser's implementation, see the comments
in <a href="https://doc.rust-lang.org/nightly/nightly-rustc/syntax/ext/tt/macro_parser/"><code>src/libsyntax/ext/tt/macro_parser.rs</code></a>.</p>
<a class="header" href="#hygiene" id="hygiene"><h3>Hygiene</h3></a>
<p>If you have ever used C/C++ preprocessor macros, you know that there are some
annoying and hard-to-debug gotchas! For example, consider the following C code:</p>
<pre><code class="language-c">#define DEFINE_FOO struct Bar {int x;}; struct Foo {Bar bar;};

// Then, somewhere else
struct Bar {
    ...
};

DEFINE_FOO
</code></pre>
<p>Most people avoid writing C like this – and for good reason: it doesn't
compile. The <code>struct Bar</code> defined by the macro clashes names with the <code>struct Bar</code> defined in the code. Consider also the following example:</p>
<pre><code class="language-c">#define DO_FOO(x) {\
    int y = 0;\
    foo(x, y);\
    }

// Then elsewhere
int y = 22;
DO_FOO(y);
</code></pre>
<p>Do you see the problem? We wanted to generate a call <code>foo(22, 0)</code>, but instead
we got <code>foo(0, 0)</code> because the macro defined its own <code>y</code>!</p>
<p>These are both examples of <em>macro hygiene</em> issues. <em>Hygiene</em> relates to how to
handle names defined <em>within a macro</em>. In particular, a hygienic macro system
prevents errors due to names introduced within a macro. Rust macros are hygienic
in that they do not allow one to write the sorts of bugs above.</p>
<p>At a high level, hygiene within the rust compiler is accomplished by keeping
track of the context where a name is introduced and used. We can then
disambiguate names based on that context. Future iterations of the macro system
will allow greater control to the macro author to use that context. For example,
a macro author may want to introduce a new name to the context where the macro
was called. Alternately, the macro author may be defining a variable for use
only within the macro (i.e. it should not be visible outside the macro).</p>
<p>In rustc, this &quot;context&quot; is tracked via <code>Span</code>s.</p>
<p>TODO: what is call-site hygiene? what is def-site hygiene?</p>
<p>TODO</p>
<a class="header" href="#procedural-macros" id="procedural-macros"><h3>Procedural Macros</h3></a>
<p>TODO</p>
<a class="header" href="#custom-derive" id="custom-derive"><h3>Custom Derive</h3></a>
<p>TODO</p>
<p>TODO: maybe something about macros 2.0?</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="test-implementation.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="name-resolution.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a href="test-implementation.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="name-resolution.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
